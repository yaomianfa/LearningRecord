loop.py是由trezor项目中移植过来 可以单独运行用于学习trezor的事件循环
此处用的是生成器协程方式，通过在iter中定义yield实现生成器协程，注意该用法在python中不支持
要支持需要添加await方法，这里已经在syscall中统一添加了await方法来支持
trezor为什么要用自己的事件循环的理解
1.原始的asyncio过于庞大，不可控，自定义可以实现更好的资源控制和内存占用控制
2.自定义事件主循环可以很好将底层IO和异步机制结合起来，实现业务层与底层IO的回调通知机制
3.更好的实现休眠机制的定义，自定义事件主循环可以很好的发现下次调度的时机从而实现闲时休眠。

对于嵌入式来说，自定义操控能够比较透明且直接的实现功能，可控性高

事件循环的主要工作：
python层面可以理解为提供了协程(协程暂停，协程恢复)的方法
但是协程什么时候恢复的控制机制，就是事件循环的工作
事件循环里面也提供一些SYSCALL(sleep,spawn,wait[等待底层IO])等辅助协程运行的函数
事件循环里处理任务的恢复运行（syscall,IO处理）

伪代码：
获取最近的协程任务时间
在任务时间还没到达前轮询底层IO，如IO就绪通知等待任务
协程deadline到，取出协程恢复协程运行

整体协程的恢复调度依赖（1.时间唤醒（如sleep后或者定时）,2.底层IO消息通知唤醒，3.自定义的chan和mailbox机制）

SYSCALL基类（iter方法,await方法【只有标准python或者类型检查时需要】,handle方法(负责syscall的额外逻辑处理)）

